#!/usr/bin/env clj
(ns update-clj-kondo-hook
  "Script to regenerate clj-kondo hook from proximum.specification.

   This ensures the hook stays in sync with the API specification.

   Usage:
     ./scripts/update-clj-kondo-hook.clj
     or
     clj -M scripts/update-clj-kondo-hook.clj"
  (:require [proximum.specification :as spec]
            [clojure.string :as str]
            [clojure.java.io :as io]))

(defn generate-hook-code
  "Generate the complete hook file content from the API specification."
  []
  (let [operations (sort (map name (keys spec/api-specification)))
        quoted-ops (str/join "\n                        "
                            (map #(str "'" %) operations))
        hook-template
        (str "(ns hooks.proximum.codegen\n"
             "  \"clj-kondo hooks for proximum.codegen.clojure macros.\n\n"
             "   These hooks teach clj-kondo about the emit-api and def-api-fn macros\n"
             "   that generate the public API from proximum.specification.\n\n"
             "   Auto-generated by scripts/update-clj-kondo-hook.clj\n"
             "   DO NOT EDIT MANUALLY - your changes will be overwritten!\"\n"
             "  (:require [clj-kondo.hooks-api :as api]))\n\n"
             "(defn def-api-fn\n"
             "  \"Hook for def-api-fn macro.\n\n"
             "   Transforms (def-api-fn :insert) into (def insert impl-fn)\n"
             "   so clj-kondo understands the generated function definition.\"\n"
             "  [{:keys [node]}]\n"
             "  (let [children (:children node)\n"
             "        [_def-api-fn-sym op-key] children]\n"
             "    (when-not op-key\n"
             "      (throw (ex-info \"def-api-fn requires an operation key\" {})))\n\n"
             "    ;; Extract the operation name from the keyword\n"
             "    (let [op-name (-> op-key\n"
             "                      api/sexpr\n"
             "                      name\n"
             "                      symbol\n"
             "                      api/token-node)\n"
             "          ;; Create a placeholder implementation symbol\n"
             "          impl-sym (api/token-node 'implementation-fn)]\n"
             "      ;; Transform to: (def op-name impl-sym)\n"
             "      {:node (api/list-node\n"
             "              [(api/token-node 'def)\n"
             "               op-name\n"
             "               impl-sym])})))\n\n"
             "(defn emit-api\n"
             "  \"Hook for emit-api macro.\n\n"
             "   Transforms (emit-api proximum.specification/api-specification)\n"
             "   into a series of (def function-name impl-fn) forms\n"
             "   so clj-kondo understands all generated API functions.\n\n"
             "   Generated from proximum.specification/api-specification.\n"
             "   Contains " (count operations) " API operations.\"\n"
             "  [{:keys [node]}]\n"
             "  (let [children (:children node)\n"
             "        [_emit-api-sym _spec-sym] children]\n\n"
             "    ;; List of all API operations in proximum.specification/api-specification\n"
             "    ;; Auto-generated - DO NOT EDIT MANUALLY\n"
             "    (let [api-operations [" quoted-ops "]\n"
             "          ;; Create a (do (def fn1 impl) (def fn2 impl) ...) form\n"
             "          def-forms (map (fn [op-name]\n"
             "                          (api/list-node\n"
             "                           [(api/token-node 'def)\n"
             "                            (api/token-node op-name)\n"
             "                            (api/token-node 'implementation-fn)]))\n"
             "                        api-operations)]\n"
             "      ;; Wrap all defs in a do block\n"
             "      {:node (api/list-node\n"
             "              (cons (api/token-node 'do) def-forms))})))\n")]
    hook-template))

(defn update-hook-file!
  "Update the clj-kondo hook file with the latest specification."
  [hook-path]
  (let [hook-code (generate-hook-code)]
    (io/make-parents hook-path)
    (spit hook-path hook-code)
    (println "✓ Updated" hook-path)))

(defn update-export-hook!
  "Update the exported hook file for library users."
  [export-path]
  (let [hook-code (generate-hook-code)]
    (io/make-parents export-path)
    (spit export-path hook-code)
    (println "✓ Updated" export-path)))

(defn verify-hook
  "Verify that the hook contains all operations from the specification."
  [hook-path]
  (let [spec-ops (set (map name (keys spec/api-specification)))
        hook-content (slurp hook-path)
        ;; Extract quoted symbols from the hook file
        hook-ops (->> hook-content
                     str/split-lines
                     (filter #(re-matches #"\s*'[\w\-!?]+.*" %))
                     (map #(-> % str/trim (str/replace #"'|," "")))
                     set)
        missing (clojure.set/difference spec-ops hook-ops)
        extra (clojure.set/difference hook-ops spec-ops)]
    (if (and (empty? missing) (empty? extra))
      (do
        (println "✓ Hook is in sync with specification")
        (println "  " (count spec-ops) "operations verified")
        true)
      (do
        (when (seq missing)
          (println "✗ Missing operations in hook:")
          (doseq [op (sort missing)]
            (println "  -" op)))
        (when (seq extra)
          (println "✗ Extra operations in hook:")
          (doseq [op (sort extra)]
            (println "  +" op)))
        false))))

(defn -main [& args]
  (let [mode (first args)
        hook-path ".clj-kondo/hooks/proximum/codegen.clj"
        export-path "resources/clj-kondo.exports/org.replikativ/proximum/hooks/proximum/codegen.clj"]
    (case mode
      "verify"
      (do
        (println "Verifying clj-kondo hook against specification...")
        (if (verify-hook hook-path)
          (System/exit 0)
          (System/exit 1)))

      "generate"
      (do
        (println "Regenerating clj-kondo hooks from specification...")
        (update-hook-file! hook-path)
        (update-export-hook! export-path)
        (println)
        (verify-hook hook-path)
        (println)
        (println "Done! The hooks have been updated."))

      ;; Default: generate
      (do
        (println "Regenerating clj-kondo hooks from specification...")
        (update-hook-file! hook-path)
        (update-export-hook! export-path)
        (println)
        (verify-hook hook-path)
        (println)
        (println "Done! The hooks have been updated.")
        (println)
        (println "Usage:")
        (println "  ./scripts/update-clj-kondo-hook.clj         # Regenerate hooks")
        (println "  ./scripts/update-clj-kondo-hook.clj verify  # Verify sync")
        (println "  ./scripts/update-clj-kondo-hook.clj generate # Explicitly generate")))))

;; Run if executed as script
(when (= *file* (System/getProperty "babashka.file"))
  (-main))

;; Also support running with clj
(when-not (= "true" (System/getProperty "clojure.test.load.only"))
  (apply -main *command-line-args*))
